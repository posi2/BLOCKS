# -*- coding: utf-8 -*-
"""cotton_price_prediction_training.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ixlj9WwDPS8WOla75KYwtBNBmDWPBqIU
"""

import pandas as pd 
import numpy
from sklearn.metrics import mean_squared_error
from matplotlib import pyplot
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Flatten
from keras.layers import LSTM
from math import sqrt
from numpy import split
from numpy import array
df = pd.read_excel("datafile.xls")
df.head(144)

len(df['modal_price'])

df.describe()

df.dtypes

def weekend(cell):
    return 1 if( cell.dayofweek == 5 or cell.dayofweek == 6) else 0

df['Date'] = pd.to_datetime(df.arrival_date,dayfirst = True)
df['Day'] = df.Date.dt.day
df['month'] = df.Date.dt.month
df['year'] = df.Date.dt.year
df['day_of_week'] = df.Date.dt.dayofweek
df['weekend'] = df.Date.apply(weekend)
df.dtypes

df.sort_values(by='Date',inplace = True)
df.head(100)

df.tail(10)

df_modal_price = df['modal_price'][:1000]
df_modal_price = numpy.array(df_modal_price,ndmin=1)
df_modal_price

type(df_modal_price)

from pandas import DataFrame
from pandas import concat

def series_to_supervised(data, n_in=1, n_out=1, dropnan=True):
	"""
	Frame a time series as a supervised learning dataset.
	Arguments:
		data: Sequence of observations as a list or NumPy array.
		n_in: Number of lag observations as input (X).
		n_out: Number of observations as output (y).
		dropnan: Boolean whether or not to drop rows with NaN values.
	Returns:
		Pandas DataFrame of series framed for supervised learning.
	"""
	n_vars = 1 if type(data) is numpy.ndarray else data.shape[1]
	df = DataFrame(data)
	cols, names = list(), list()
	# input sequence (t-n, ... t-1)
	for i in range(n_in, 0, -1):
		cols.append(df.shift(i))
		names += [('var%d(t-%d)' % (j+1, i)) for j in range(n_vars)]
	# forecast sequence (t, t+1, ... t+n)
	for i in range(0, n_out):
		cols.append(df.shift(-i))
		if i == 0:
			names += [('var%d(t)' % (j+1)) for j in range(n_vars)]
		else:
			names += [('var%d(t+%d)' % (j+1, i)) for j in range(n_vars)]
	# put it all together
	agg = concat(cols, axis=1)
	agg.columns = names
	# drop rows with NaN values
	if dropnan:
		agg.dropna(inplace=True)
	return agg



df_modal_price_supervised = series_to_supervised(df_modal_price, 1, 5)
print(df_modal_price_supervised)

def split_dataset(data):
	# split into standard weeks
	train, test = data[1:-328], data[-328:-6]
	# restructure into windows of weekly data
	train = array(split(train, len(train)/7))
	test = array(split(test, len(test)/7))
	return train, test

# train the model
def build_model(train, n_input):
	# prepare data
	train_x, train_y = to_supervised(train, n_input)
	# define parameters
	verbose, epochs, batch_size = 0, 70, 16
	n_timesteps, n_features, n_outputs = train_x.shape[1], train_x.shape[2], train_y.shape[1]
	# define model
	model = Sequential()
	model.add(LSTM(200, activation='relu', input_shape=(n_timesteps, n_features)))
	model.add(Dense(100, activation='relu'))
	model.add(Dense(n_outputs))
	model.compile(loss='mse', optimizer='adam')
	# fit network
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)
	return model

def evaluate_model(train, test, n_steps, n_length, n_input):
	# fit model
	model = build_model(train, n_steps, n_length, n_input)
	# history is a list of weekly data
	history = [x for x in train]
	# walk-forward validation over each week
	predictions = list()
	for i in range(len(test)):
		# predict the week
		yhat_sequence = forecast(model, history, n_steps, n_length, n_input)
		# store the predictions
		predictions.append(yhat_sequence)
		# get real observation and add to history for predicting the next week
		history.append(test[i, :])
	# evaluate predictions days for each week
	predictions = array(predictions)
	score, scores = evaluate_forecasts(test[:, :, 0], predictions)
	return score, scores

train, test = split_dataset(df_modal_price_supervised)
# evaluate model and get scores
n_input = 5
score, scores = evaluate_model(train, test, n_input)
# summarize scores
summarize_scores('lstm', score, scores)
# plot scores

district_data = df[:140]
district_data.head()

district_data['Date'] = pd.to_datetime(district_data.arrival_date,dayfirst = True)
district_data['Day'] = district_data.Date.dt.day
district_data['month'] = district_data.Date.dt.month
district_data['year'] = district_data.Date.dt.year
district_data['day_of_week'] = district_data.Date.dt.dayofweek
district_data['weekend'] = district_data.Date.apply(weekend)

district_data.sort_values(by = 'Date', inplace=True)
district_data.head()

from statsmodels.tsa.arima_model import ARIMA
from matplotlib import pyplot as plt

model = ARIMA(df.modal_price, order = (5,0,4))
model_fitted = model.fit(disp = -1)
plt.plot(df.modal_price)
plt.plot(model_fitted.fittedvalues,color='red')
print(model_fitted.summary())

